{% extends 'layouts/app.html' %}

{% block title %}{{ title }} - Resolve Eng{% endblock %}

{% block extra_css %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
<!-- Leaflet-measure CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-measure@3.1.0/dist/leaflet-measure.css"/>
<style>
    #map {
        height: calc(100vh - 300px);
        min-height: 500px;
        width: 100%;
        border-radius: 8px;
        z-index: 1;
    }
    .thumbnail-popup {
        text-align: center;
    }
    .thumbnail-popup img {
        width: 150px;
        height: auto;
        margin-bottom: 5px;
        cursor: pointer;
        border-radius: 4px;
    }
    .leaflet-popup-content-wrapper {
        border-radius: 8px;
        padding: 5px;
    }
    .custom-file-upload {
        border: 2px dashed #ccc;
        display: inline-block;
        padding: 20px 40px;
        cursor: pointer;
        width: 100%;
        text-align: center;
        margin-bottom: 20px;
        border-radius: 8px;
        background-color: #f8f9fa;
        transition: all 0.3s;
    }
    .custom-file-upload:hover {
        background-color: #e9ecef;
        border-color: #0d6efd;
    }
    .hidden-input {
        display: none;
    }
    /* Cursor styles for measurement tools */
    .cursor-crosshair {
        cursor: crosshair !important;
    }
    /* Measurement info box */
    #measureInfo {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 8px 15px;
        border-radius: 20px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1000;
        font-weight: 500;
        display: none;
        pointer-events: none;
    }
</style>
{% endblock %}

{% block body_classes %}full-visual{% endblock %}
{% block content %}
<div class="ds-container py-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
            <h1 class="h2">{{ title }}</h1>
            <p class="text-muted mb-0">Carregue fotos com geolocaliza√ß√£o para visualiz√°-las no mapa. Nada √© enviado ao servidor.</p>
        </div>
        <div>
            <button class="btn btn-outline-primary" onclick="document.getElementById('folderInput').click()">
                <i class="bi bi-folder-plus me-2"></i>Selecionar Pasta
            </button>
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                <i class="bi bi-images me-2"></i>Selecionar Fotos
            </button>
        </div>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="fileInput" class="hidden-input" multiple accept="image/*">
    <input type="file" id="folderInput" class="hidden-input" webkitdirectory directory multiple>

    <!-- Status Area -->
    <div id="statusArea" class="alert alert-info d-none" role="alert">
        <span id="statusText">Processando...</span>
        <div class="progress mt-2" style="height: 5px;">
            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
        </div>
    </div>

    <!-- Export Controls (Initially Hidden) -->
    <div id="exportSection" class="card mb-4 d-none">
        <div class="card-body">
            <h5 class="card-title"><i class="bi bi-file-earmark-arrow-down me-2"></i>Exporta√ß√£o de Dados</h5>
            <p class="card-text text-muted small">Exporte os pontos mapeados para utiliza√ß√£o em softwares CAD/GIS.</p>
            
            <div class="d-flex gap-2 flex-wrap">
                <button id="downloadCoordinatesBtn" class="btn btn-success btn-sm">
                    <i class="bi bi-filetype-txt me-1"></i>TXT (SIRGAS 2000)
                </button>
                <button id="exportCivil3DBtn" class="btn btn-primary btn-sm">
                    <i class="bi bi-file-earmark-code me-1"></i>Civil 3D (P,N,E,Z,D)
                </button>
            </div>
        </div>
    </div>

    <!-- Map Container -->
    <div class="p-0 rounded-0 shadow-sm position-relative" style="background:var(--color-surface);border:1px solid var(--color-border);">
        <div id="measureInfo"></div>
        <div class="card-body p-0">
            <div id="map"></div>
        </div>
    </div>

    <!-- Export Coordinates Section -->
    <div id="exportSection" class="mt-3 p-3 rounded shadow-sm d-none" style="background:var(--color-surface);border:1px solid var(--color-border);">
        <div class="row align-items-center">
            <div class="col-md-8">
                <h6 class="mb-2"><i class="bi bi-download me-2"></i>Exportar Coordenadas para Civil 3D</h6>
                <p class="text-muted mb-0 small">Baixe um arquivo TXT com as coordenadas das fotos no sistema SIRGAS 2000 UTM.</p>
            </div>
            <div class="col-md-2">
                <label for="startingPointNumber" class="form-label small mb-1">N√∫mero inicial:</label>
                <input type="number" class="form-control form-control-sm" id="startingPointNumber" value="1" min="1">
            </div>
            <div class="col-md-2 text-end">
                <button id="downloadCoordinatesBtn" class="btn btn-success mt-3">
                    <i class="bi bi-file-earmark-text me-1"></i>Baixar TXT
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modal for Full Image -->
<div class="modal fade" id="imageModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-xl modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header border-0">
                <h5 class="modal-title" id="imageModalTitle">Visualiza√ß√£o</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center p-0 bg-dark">
                <img id="fullImage" src="" class="img-fluid" style="max-height: 85vh;" alt="Full size">
            </div>
        </div>
    </div>
<!-- Modal preserved -->
</div>
{% endblock %}

{% block extra_js %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
<!-- Leaflet-measure plugin for distance, area, and route measurements -->
<script src="https://unpkg.com/leaflet-measure@3.1.0/dist/leaflet-measure.umd.js"></script>
<!-- ExifReader (better than exif-js for modern usage) or exif-js -->
<script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
<!-- Proj4js for coordinate transformations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.min.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Map
        const map = L.map('map').setView([-14.235, -51.925], 4); // Center of Brazil

        // Define different tile layers
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            name: 'Mapa Padr√£o'
        });

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 18,
            attribution: '&copy; <a href="https://www.arcgisonline.com/">Esri</a>',
            name: 'Sat√©lite'
        });

        const topoLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.arcgisonline.com/">Esri</a>',
            name: 'Relevo com Rios'
        });

        // Add default layer
        osmLayer.addTo(map);

        // Layer control for switching between maps
        const baseMaps = {
            'Mapa Padr√£o': osmLayer,
            'Sat√©lite': satelliteLayer,
            'Relevo com Rios': topoLayer
        };

        L.control.layers(baseMaps).addTo(map);

        // Variables for measurement
        let drawingMode = null;
        let completedMode = null;
        let points = [];
        let polyline = null;
        let polygon = null;
        let tempLine = null;
        let markerGroup = L.featureGroup().addTo(map);
        let measurementClickHandler = null;
        let measurementMoveHandler = null;

        // Add measurement button to map
        const MeasureControl = L.Control.extend({
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                
                const measureBtn = L.DomUtil.create('button', 'leaflet-control-custom', container);
                measureBtn.innerHTML = 'üìè';
                measureBtn.title = 'Ferramentas de Medida';
                measureBtn.style.width = '34px';
                measureBtn.style.height = '34px';
                measureBtn.style.backgroundColor = 'white';
                measureBtn.style.border = '2px solid rgba(0,0,0,0.2)';
                measureBtn.style.borderRadius = '4px';
                measureBtn.style.cursor = 'pointer';
                measureBtn.style.fontSize = '18px';
                
                L.DomEvent.on(measureBtn, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    toggleMeasurementPanel();
                });
                
                return container;
            }
        });

        const measureControl = new MeasureControl({ position: 'topleft' });
        measureControl.addTo(map);

        // Create measurement panel
        const measurePanel = L.control({ position: 'topleft' });
        
        measurePanel.onAdd = function(map) {
            const div = L.DomUtil.create('div', 'leaflet-control leaflet-control-layers');
            div.id = 'measurePanel';
            div.style.display = 'none';
            div.style.minWidth = '200px';
            div.style.background = 'white';
            div.style.borderRadius = '4px';
            div.style.border = '2px solid rgba(0,0,0,0.2)';
            div.style.padding = '10px';
            div.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #ddd; padding-bottom: 5px;">
                    Ferramentas de Medida
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 12px; font-weight: bold; display: block; margin-bottom: 4px;">Unidade:</label>
                    <select id="unitSelector" class="form-select form-select-sm" style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                        <option value="meters" selected>Metros (m / m¬≤)</option>
                        <option value="auto">Autom√°tico (m/km)</option>
                        <option value="imperial">Imperial (ft / mi)</option>
                    </select>
                </div>
                <div id="measureOptions">
                    <label style="display: block; margin: 8px 0; cursor: pointer; user-select: none;">
                        <input type="radio" name="measureType" value="distance"> 
                        <span>üìè Dist√¢ncia</span>
                    </label>
                    <label style="display: block; margin: 8px 0; cursor: pointer; user-select: none;">
                        <input type="radio" name="measureType" value="area"> 
                        <span>üìê √Årea</span>
                    </label>
                    <label style="display: block; margin: 8px 0; cursor: pointer; user-select: none;">
                        <input type="radio" name="measureType" value="route"> 
                        <span>üõ£Ô∏è Percurso</span>
                    </label>
                    <hr style="margin: 10px 0;">
                    <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
                        <strong>Modo:</strong> <span id="currentMode">Nenhum</span><br>
                        <strong>Pontos:</strong> <span id="pointCount">0</span><br>
                        <div id="liveResult" style="margin-top: 5px; font-weight: bold; color: #0d6efd;"></div>
                    </div>
                    <button id="clearBtn" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        Limpar
                    </button>
                </div>
            `;
            return div;
        };

        measurePanel.addTo(map);

        function toggleMeasurementPanel() {
            const panel = document.getElementById('measurePanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function clearMeasurements() {
            map.off('click', measurementClickHandler);
            map.off('mousemove', measurementMoveHandler);
            if (polyline) map.removeLayer(polyline);
            if (polygon) map.removeLayer(polygon);
            if (tempLine) map.removeLayer(tempLine);
            markerGroup.clearLayers();
            points = [];
            drawingMode = null;
            completedMode = null;
            document.querySelectorAll('input[name="measureType"]').forEach(el => el.checked = false);
            document.getElementById('currentMode').textContent = 'Nenhum';
            document.getElementById('pointCount').textContent = '0';
            document.getElementById('liveResult').textContent = '';
            document.getElementById('measureInfo').style.display = 'none';
            document.querySelector('.leaflet-container').classList.remove('cursor-crosshair');
        }

        // Event listeners for measurement selection
        document.addEventListener('change', function(e) {
            if (e.target.name === 'measureType') {
                // Stop previous mode
                map.off('click', measurementClickHandler);
                map.off('mousemove', measurementMoveHandler);
                clearMeasurements();
                
                // Re-check the radio button since clearMeasurements unchecks it
                e.target.checked = true;
                
                drawingMode = e.target.value;
                const modeNames = {
                    'distance': 'Dist√¢ncia (2 pontos)',
                    'area': '√Årea (3+ pontos)',
                    'route': 'Percurso (2+ pontos)'
                };
                
                document.getElementById('currentMode').textContent = modeNames[drawingMode];
                document.querySelector('.leaflet-container').classList.add('cursor-crosshair');
                
                // Set up handlers
                measurementClickHandler = handleMeasurementClick;
                measurementMoveHandler = handleMeasurementMove;
                map.on('click', measurementClickHandler);
                map.on('mousemove', measurementMoveHandler);
                
                // Show info box
                const infoBox = document.getElementById('measureInfo');
                infoBox.style.display = 'block';
                infoBox.innerHTML = 'Clique no mapa para come√ßar';
            }
        });

        function handleMeasurementMove(e) {
            if (!drawingMode || points.length === 0) return;

            const currentLatLng = e.latlng;
            const lastPoint = points[points.length - 1];
            
            // Draw temp line
            if (tempLine) map.removeLayer(tempLine);
            
            // For area, close the loop visually
            let tempPoints = [lastPoint, currentLatLng];
            if (drawingMode === 'area' && points.length >= 2) {
                tempPoints = [lastPoint, currentLatLng, points[0]];
            }
            
            tempLine = L.polyline(tempPoints, {
                color: '#666',
                weight: 2,
                dashArray: '5, 10',
                opacity: 0.6
            }).addTo(map);

            // Calculate live results
            let resultText = '';
            
            if (drawingMode === 'distance') {
                const dist = calculateDistance(lastPoint, currentLatLng);
                resultText = `Dist√¢ncia: ${formatDistance(dist.meters)}`;
            } else if (drawingMode === 'route') {
                const currentTotal = calculateTotalDistance(points).meters;
                const segment = calculateDistance(lastPoint, currentLatLng).meters;
                resultText = `Total: ${formatDistance(currentTotal + segment)}`;
            } else if (drawingMode === 'area' && points.length >= 2) {
                // Calculate area with potential new point
                const tempPolyPoints = [...points, currentLatLng];
                const area = calculateArea(tempPolyPoints);
                resultText = `√Årea: ${formatArea(area)}`;
            }

            if (resultText) {
                document.getElementById('measureInfo').innerHTML = resultText;
                document.getElementById('liveResult').innerHTML = resultText;
            }
        }

        function handleMeasurementClick(e) {
            if (!drawingMode) return;
            
            const latlng = e.latlng;
            points.push(latlng);
            document.getElementById('pointCount').textContent = points.length;
            
            // Draw point marker
            const marker = L.circleMarker(latlng, {
                radius: 6,
                fillColor: '#0d6efd',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            });
            markerGroup.addLayer(marker);

            if (points.length > 1) {
                if (drawingMode === 'distance' && points.length === 2) {
                    const distance = calculateDistance(points[0], points[1]);
                    const text = `Dist√¢ncia Final: ${formatDistance(distance.meters)}`;
                    document.getElementById('measureInfo').innerHTML = text;
                    document.getElementById('liveResult').innerHTML = text;
                    
                    completedMode = 'distance';
                    finishMeasurement();
                }
                
                if (drawingMode === 'route') {
                    // Draw line for route
                    if (polyline) map.removeLayer(polyline);
                    polyline = L.polyline(points, {
                        color: '#0d6efd',
                        weight: 3,
                        opacity: 0.8
                    }).addTo(map);
                }
                
                if (drawingMode === 'area' && points.length >= 3) {
                    // Draw polygon for area
                    if (polygon) map.removeLayer(polygon);
                    polygon = L.polygon(points, {
                        color: '#0d6efd',
                        fillColor: '#0d6efd',
                        fillOpacity: 0.3,
                        weight: 2
                    }).addTo(map);
                }
            }
        }

        function finishMeasurement() {
            map.off('click', measurementClickHandler);
            map.off('mousemove', measurementMoveHandler);
            if (tempLine) map.removeLayer(tempLine);
            document.querySelector('.leaflet-container').classList.remove('cursor-crosshair');
            document.getElementById('currentMode').textContent = 'Completo';
        }

        function calculateDistance(latlng1, latlng2) {
            const R = 6371e3; // metres
            const œÜ1 = latlng1.lat * Math.PI/180; // œÜ, Œª in radians
            const œÜ2 = latlng2.lat * Math.PI/180;
            const ŒîœÜ = (latlng2.lat-latlng1.lat) * Math.PI/180;
            const ŒîŒª = (latlng2.lng-latlng1.lng) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            const d = R * c; // in metres
            return {
                km: d / 1000,
                meters: d
            };
        }

        function calculateTotalDistance(pts) {
            let total = 0;
            for (let i = 0; i < pts.length - 1; i++) {
                total += calculateDistance(pts[i], pts[i + 1]).meters;
            }
            return { km: total / 1000, meters: total };
        }

        function calculateArea(pts) {
            if (pts.length < 3) return 0;
            // Simple planar approximation for small areas (sufficient for this use case)
            // For better accuracy on large scales, spherical excess should be used
            let area = 0;
            for (let i = 0; i < pts.length; i++) {
                const p1 = pts[i];
                const p2 = pts[(i + 1) % pts.length];
                area += p1.lng * p2.lat - p2.lng * p1.lat;
            }
            // Convert square degrees to square meters (approximate at polygon center latitude)
            const center = getPolygonCenter(pts);
            const latRad = center.lat * Math.PI / 180;
            const metersPerDegreeLat = 111132.954 - 559.822 * Math.cos(2 * latRad) + 1.175 * Math.cos(4 * latRad);
            const metersPerDegreeLng = 111132.954 * Math.cos(latRad);
            
            return Math.abs(area) / 2 * metersPerDegreeLat * metersPerDegreeLng;
        }

        function getPolygonCenter(pts) {
            let lat = 0, lng = 0;
            pts.forEach(p => {
                lat += p.lat;
                lng += p.lng;
            });
            return L.latLng(lat / pts.length, lng / pts.length);
        }

        function formatDistance(meters) {
            const unit = document.getElementById('unitSelector').value;
            
            if (unit === 'imperial') {
                const feet = meters * 3.28084;
                if (feet >= 5280) {
                    return `${(feet / 5280).toFixed(2)} mi`;
                }
                return `${feet.toFixed(0)} ft`;
            }
            
            if (unit === 'auto') {
                if (meters >= 1000) {
                    return `${(meters / 1000).toFixed(2)} km`;
                }
                return `${meters.toFixed(0)} m`;
            }
            
            // Default 'meters'
            return `${meters.toFixed(2)} m`;
        }

        function formatArea(sqMeters) {
            const unit = document.getElementById('unitSelector').value;
            
            if (unit === 'imperial') {
                const sqFeet = sqMeters * 10.7639;
                if (sqFeet >= 43560) { // 1 acre
                    return `${(sqFeet / 43560).toFixed(2)} ac`;
                }
                return `${sqFeet.toFixed(0)} ft¬≤`;
            }
            
            if (unit === 'auto') {
                if (sqMeters >= 1000000) {
                    return `${(sqMeters / 1000000).toFixed(2)} km¬≤`;
                }
                if (sqMeters >= 10000) {
                    return `${(sqMeters / 10000).toFixed(2)} ha`;
                }
                return `${sqMeters.toFixed(0)} m¬≤`;
            }
            
            // Default 'meters'
            return `${sqMeters.toFixed(2)} m¬≤`;
        }

        // Handle ESC key to finish measurement
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && drawingMode && points.length > 0) {
                completedMode = drawingMode;
                finishMeasurement();
                
                if (completedMode === 'area') {
                    // Close the polygon visually
                    if (polygon) map.removeLayer(polygon);
                    polygon = L.polygon(points, {
                        color: '#0d6efd',
                        fillColor: '#0d6efd',
                        fillOpacity: 0.3,
                        weight: 2
                    }).addTo(map);
                    
                    const area = calculateArea(points);
                    const text = `√Årea Final: ${formatArea(area)}`;
                    document.getElementById('measureInfo').innerHTML = text;
                    document.getElementById('liveResult').innerHTML = text;
                }
                
                if (completedMode === 'route') {
                    const totalDistance = calculateTotalDistance(points);
                    const text = `Percurso Total: ${formatDistance(totalDistance.meters)}`;
                    document.getElementById('measureInfo').innerHTML = text;
                    document.getElementById('liveResult').innerHTML = text;
                }
            }
        });

        // Unit selector handler
        document.getElementById('unitSelector').addEventListener('change', function() {
            if (completedMode && points.length > 0) {
                let text = '';
                if (completedMode === 'distance') {
                     const dist = calculateDistance(points[0], points[1]);
                     text = `Dist√¢ncia Final: ${formatDistance(dist.meters)}`;
                } else if (completedMode === 'route') {
                     const total = calculateTotalDistance(points);
                     text = `Percurso Total: ${formatDistance(total.meters)}`;
                } else if (completedMode === 'area') {
                     const area = calculateArea(points);
                     text = `√Årea Final: ${formatArea(area)}`;
                }
                
                if (text) {
                    document.getElementById('measureInfo').innerHTML = text;
                    document.getElementById('liveResult').innerHTML = text;
                }
            }
        });

        // Clear button handler
        document.getElementById('clearBtn').addEventListener('click', clearMeasurements);

        const markers = L.layerGroup().addTo(map);
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const statusArea = document.getElementById('statusArea');
        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const imageModal = new bootstrap.Modal(document.getElementById('imageModal'));
        const fullImage = document.getElementById('fullImage');
        const imageModalTitle = document.getElementById('imageModalTitle');

        // Array to store photo data for export
        let photoDataForExport = [];

        // Define WGS84 projection
        proj4.defs('WGS84', '+proj=longlat +datum=WGS84 +no_defs');

        // Function to get UTM zone from longitude
        function getUTMZone(longitude) {
            return Math.floor((longitude + 180) / 6) + 1;
        }

        // Function to determine if location is in southern hemisphere
        function isSouthernHemisphere(latitude) {
            return latitude < 0;
        }

        // Function to get SIRGAS 2000 UTM projection string
        function getSirgas2000UTMProj(zone, isSouth) {
            // SIRGAS 2000 uses GRS80 ellipsoid, compatible with WGS84 for most purposes
            // EPSG codes for SIRGAS 2000 UTM zones in Brazil: 31976-31984 (zones 18S-26S)
            // For southern hemisphere, add +south parameter
            if (isSouth) {
                return `+proj=utm +zone=${zone} +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs`;
            }
            return `+proj=utm +zone=${zone} +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs`;
        }

        // Function to convert WGS84 to SIRGAS 2000 UTM
        function convertToSirgas2000UTM(lat, lon) {
            const zone = getUTMZone(lon);
            const isSouth = isSouthernHemisphere(lat);
            const utmProj = getSirgas2000UTMProj(zone, isSouth);
            
            const result = proj4('WGS84', utmProj, [lon, lat]);
            return {
                easting: result[0],
                northing: result[1],
                zone: zone,
                hemisphere: isSouth ? 'S' : 'N'
            };
        }

        function handleFiles(files) {
            if (!files || files.length === 0) return;

            statusArea.classList.remove('d-none');
            statusText.textContent = `Processando ${files.length} arquivos...`;
            progressBar.style.width = '0%';

            // Clear existing markers and photo data
            markers.clearLayers();
            photoDataForExport = [];

            let processedCount = 0;
            const bounds = L.latLngBounds();
            let hasPhotos = false;

            Array.from(files).forEach((file, index) => {
                // Only process images
                if (!file.type.match('image.*')) {
                    checkFinished();
                    return;
                }

                EXIF.getData(file, function() {
                    const lat = EXIF.getTag(this, "GPSLatitude");
                    const lon = EXIF.getTag(this, "GPSLongitude");
                    const latRef = EXIF.getTag(this, "GPSLatitudeRef");
                    const lonRef = EXIF.getTag(this, "GPSLongitudeRef");
                    const altitude = EXIF.getTag(this, "GPSAltitude");
                    const altitudeRef = EXIF.getTag(this, "GPSAltitudeRef");

                    if (lat && lon && latRef && lonRef) {
                        const latDec = convertDMSToDD(lat, latRef);
                        const lonDec = convertDMSToDD(lon, lonRef);

                        if (!isNaN(latDec) && !isNaN(lonDec)) {
                            const objectUrl = URL.createObjectURL(file);

                            // Get altitude value (default to 0 if not available)
                            let altitudeValue = 0;
                            if (altitude !== undefined && altitude !== null) {
                                const parsedAlt = typeof altitude === 'number' ? altitude : parseFloat(altitude);
                                // Only use parsed value if it's a valid number
                                if (!isNaN(parsedAlt)) {
                                    altitudeValue = parsedAlt;
                                    // Check altitude reference (0 = above sea level, 1 = below sea level)
                                    if (altitudeRef === 1) {
                                        altitudeValue = -altitudeValue;
                                    }
                                }
                            }

                            // Store photo data for export
                            photoDataForExport.push({
                                filename: file.name,
                                latitude: latDec,
                                longitude: lonDec,
                                altitude: altitudeValue
                            });

                            const marker = L.marker([latDec, lonDec]);
                            const popupContent = `
                                <div class="thumbnail-popup">
                                    <img src="${objectUrl}" onclick="openModal('${objectUrl}', '${file.name.replace(/'/g, "\\'")}')">
                                    <br>
                                    <button class="btn btn-sm btn-primary mt-1" onclick="openModal('${objectUrl}', '${file.name.replace(/'/g, "\\'")}')">
                                        <i class="bi bi-zoom-in"></i> Expandir
                                    </button>
                                </div>
                            `;

                            marker.bindPopup(popupContent);
                            markers.addLayer(marker);
                            bounds.extend([latDec, lonDec]);
                            hasPhotos = true;
                        }
                    }

                    checkFinished();
                });

                function checkFinished() {
                    processedCount++;
                    const percent = (processedCount / files.length) * 100;
                    progressBar.style.width = `${percent}%`;

                    if (processedCount === files.length) {
                        statusText.textContent = `Conclu√≠do! ${markers.getLayers().length} fotos mapeadas.`;
                        setTimeout(() => {
                            statusArea.classList.add('d-none');
                        }, 3000);

                        if (hasPhotos) {
                            map.fitBounds(bounds, { padding: [50, 50], maxZoom: 18 });
                            // Show export section when photos are loaded
                            document.getElementById('exportSection').classList.remove('d-none');
                        } else {
                            alert('Nenhuma informa√ß√£o de GPS encontrada nas fotos selecionadas.');
                            // Hide export section if no photos with GPS
                            document.getElementById('exportSection').classList.add('d-none');
                        }
                    }
                }
            });
        }

        // Function to generate and download TXT file
        function downloadCoordinatesTXT() {
            if (photoDataForExport.length === 0) {
                alert('Nenhuma foto com coordenadas carregada.');
                return;
            }

            const startingNumber = parseInt(document.getElementById('startingPointNumber').value) || 1;
            let txtContent = '';

            photoDataForExport.forEach((photo, index) => {
                const pointNumber = startingNumber + index;
                const utmCoords = convertToSirgas2000UTM(photo.latitude, photo.longitude);
                
                // Format for Civil 3D: point_number,description,easting,northing,elevation
                // Comma-separated values in TXT file, no thousand separators, decimal point as separator
                const line = [
                    pointNumber,
                    photo.filename.replace(/,/g, '_'), // Sanitize filename
                    utmCoords.easting.toFixed(3),
                    utmCoords.northing.toFixed(3),
                    photo.altitude.toFixed(3)
                ].join(',');
                
                txtContent += line + '\n';
            });

            // Remove trailing newline
            txtContent = txtContent.trimEnd();

            // Create and trigger download
            const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'coordenadas_fotos_sirgas2000.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Download button event listener
        document.getElementById('downloadCoordinatesBtn').addEventListener('click', downloadCoordinatesTXT);

        // Civil 3D Export
        document.getElementById('exportCivil3DBtn').addEventListener('click', function() {
            if (photoDataForExport.length === 0) {
                alert('N√£o h√° dados para exportar.');
                return;
            }

            let content = '';
            // Civil 3D format: Point Number, Northing, Easting, Elevation, Description (P,N,E,Z,D)
            // Using comma as delimiter
            
            photoDataForExport.forEach((photo, index) => {
                const pointNumber = index + 1;
                const utm = convertToSirgas2000UTM(photo.latitude, photo.longitude);
                
                // Note: Civil 3D usually expects P,N,E,Z,D or P,E,N,Z,D depending on settings.
                // Standard is often P,E,N,Z,D (Point, Easting, Northing, Elevation, Description)
                // But the request asked for: Ponto, Nome_da_Foto, Este, Norte, Cota
                // Let's follow the request: Point, Name, Easting, Northing, Elevation
                
                // Format: Ponto,Nome_da_Foto,Este,Norte,Cota
                const line = `${pointNumber},${photo.filename},${utm.easting.toFixed(3)},${utm.northing.toFixed(3)},${photo.altitude.toFixed(3)}\r\n`;
                content += line;
            });

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pontos_civil3d.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // DMS to Decimal Degrees converter
        function convertDMSToDD(dms, ref) {
            let dd = dms[0] + dms[1] / 60 + dms[2] / 3600;
            if (ref === "S" || ref === "W") {
                dd = dd * -1;
            }
            return dd;
        }

        // Global function for modal (needs to be on window because it's called from HTML string in popup)
        window.openModal = function(url, title) {
            fullImage.src = url;
            imageModalTitle.textContent = title || 'Visualiza√ß√£o';
            imageModal.show();
        };

        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        folderInput.addEventListener('change', (e) => handleFiles(e.target.files));
    });
</script>
{% endblock %}